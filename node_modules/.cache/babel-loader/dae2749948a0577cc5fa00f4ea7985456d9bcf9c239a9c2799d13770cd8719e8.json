{"ast":null,"code":"export default function indentString(string) {\n  let count = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const {\n    indent = ' ',\n    includeEmptyLines = false\n  } = options;\n  if (typeof string !== 'string') {\n    throw new TypeError(`Expected \\`input\\` to be a \\`string\\`, got \\`${typeof string}\\``);\n  }\n  if (typeof count !== 'number') {\n    throw new TypeError(`Expected \\`count\\` to be a \\`number\\`, got \\`${typeof count}\\``);\n  }\n  if (count < 0) {\n    throw new RangeError(`Expected \\`count\\` to be at least 0, got \\`${count}\\``);\n  }\n  if (typeof indent !== 'string') {\n    throw new TypeError(`Expected \\`options.indent\\` to be a \\`string\\`, got \\`${typeof indent}\\``);\n  }\n  if (count === 0) {\n    return string;\n  }\n  const regex = includeEmptyLines ? /^/gm : /^(?!\\s*$)/gm;\n  return string.replace(regex, indent.repeat(count));\n}","map":{"version":3,"names":["indentString","string","count","arguments","length","undefined","options","indent","includeEmptyLines","TypeError","RangeError","regex","replace","repeat"],"sources":["C:/Users/dixita/projects/NCAR-Project6/node_modules/indent-string/index.js"],"sourcesContent":["export default function indentString(string, count = 1, options = {}) {\n\tconst {\n\t\tindent = ' ',\n\t\tincludeEmptyLines = false\n\t} = options;\n\n\tif (typeof string !== 'string') {\n\t\tthrow new TypeError(\n\t\t\t`Expected \\`input\\` to be a \\`string\\`, got \\`${typeof string}\\``\n\t\t);\n\t}\n\n\tif (typeof count !== 'number') {\n\t\tthrow new TypeError(\n\t\t\t`Expected \\`count\\` to be a \\`number\\`, got \\`${typeof count}\\``\n\t\t);\n\t}\n\n\tif (count < 0) {\n\t\tthrow new RangeError(\n\t\t\t`Expected \\`count\\` to be at least 0, got \\`${count}\\``\n\t\t);\n\t}\n\n\tif (typeof indent !== 'string') {\n\t\tthrow new TypeError(\n\t\t\t`Expected \\`options.indent\\` to be a \\`string\\`, got \\`${typeof indent}\\``\n\t\t);\n\t}\n\n\tif (count === 0) {\n\t\treturn string;\n\t}\n\n\tconst regex = includeEmptyLines ? /^/gm : /^(?!\\s*$)/gm;\n\n\treturn string.replace(regex, indent.repeat(count));\n}\n"],"mappings":"AAAA,eAAe,SAASA,YAAYA,CAACC,MAAM,EAA2B;EAAA,IAAzBC,KAAK,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC;EAAA,IAAEG,OAAO,GAAAH,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC,CAAC;EACnE,MAAM;IACLI,MAAM,GAAG,GAAG;IACZC,iBAAiB,GAAG;EACrB,CAAC,GAAGF,OAAO;EAEX,IAAI,OAAOL,MAAM,KAAK,QAAQ,EAAE;IAC/B,MAAM,IAAIQ,SAAS,CACjB,gDAA+C,OAAOR,MAAO,IAC/D,CAAC;EACF;EAEA,IAAI,OAAOC,KAAK,KAAK,QAAQ,EAAE;IAC9B,MAAM,IAAIO,SAAS,CACjB,gDAA+C,OAAOP,KAAM,IAC9D,CAAC;EACF;EAEA,IAAIA,KAAK,GAAG,CAAC,EAAE;IACd,MAAM,IAAIQ,UAAU,CAClB,8CAA6CR,KAAM,IACrD,CAAC;EACF;EAEA,IAAI,OAAOK,MAAM,KAAK,QAAQ,EAAE;IAC/B,MAAM,IAAIE,SAAS,CACjB,yDAAwD,OAAOF,MAAO,IACxE,CAAC;EACF;EAEA,IAAIL,KAAK,KAAK,CAAC,EAAE;IAChB,OAAOD,MAAM;EACd;EAEA,MAAMU,KAAK,GAAGH,iBAAiB,GAAG,KAAK,GAAG,aAAa;EAEvD,OAAOP,MAAM,CAACW,OAAO,CAACD,KAAK,EAAEJ,MAAM,CAACM,MAAM,CAACX,KAAK,CAAC,CAAC;AACnD"},"metadata":{},"sourceType":"module","externalDependencies":[]}